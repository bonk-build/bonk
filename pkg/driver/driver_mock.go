// Copyright Â© 2025 Colden Cullen
// SPDX-License-Identifier: MIT

// Code generated by MockGen. DO NOT EDIT.
// Source: go.bonk.build/pkg/driver (interfaces: Driver)
//
// Generated by this command:
//
//	mockgen -destination driver_mock.go -package driver -copyright_file ../../license-header.txt -typed . Driver
//

// Package driver is a generated GoMock package.
package driver

import (
	context "context"
	reflect "reflect"

	task "go.bonk.build/pkg/task"
	gomock "go.uber.org/mock/gomock"
)

// MockDriver is a mock of Driver interface.
type MockDriver struct {
	ctrl     *gomock.Controller
	recorder *MockDriverMockRecorder
	isgomock struct{}
}

// MockDriverMockRecorder is the mock recorder for MockDriver.
type MockDriverMockRecorder struct {
	mock *MockDriver
}

// NewMockDriver creates a new mock instance.
func NewMockDriver(ctrl *gomock.Controller) *MockDriver {
	mock := &MockDriver{ctrl: ctrl}
	mock.recorder = &MockDriverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDriver) EXPECT() *MockDriverMockRecorder {
	return m.recorder
}

// AddTask mocks base method.
func (m *MockDriver) AddTask(ctx context.Context, tsk *task.Task, deps ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, tsk}
	for _, a := range deps {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddTask", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddTask indicates an expected call of AddTask.
func (mr *MockDriverMockRecorder) AddTask(ctx, tsk any, deps ...any) *MockDriverAddTaskCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, tsk}, deps...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddTask", reflect.TypeOf((*MockDriver)(nil).AddTask), varargs...)
	return &MockDriverAddTaskCall{Call: call}
}

// MockDriverAddTaskCall wrap *gomock.Call
type MockDriverAddTaskCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverAddTaskCall) Return(arg0 error) *MockDriverAddTaskCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverAddTaskCall) Do(f func(context.Context, *task.Task, ...string) error) *MockDriverAddTaskCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverAddTaskCall) DoAndReturn(f func(context.Context, *task.Task, ...string) error) *MockDriverAddTaskCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloseSession mocks base method.
func (m *MockDriver) CloseSession(ctx context.Context, sessionId task.SessionId) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CloseSession", ctx, sessionId)
}

// CloseSession indicates an expected call of CloseSession.
func (mr *MockDriverMockRecorder) CloseSession(ctx, sessionId any) *MockDriverCloseSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseSession", reflect.TypeOf((*MockDriver)(nil).CloseSession), ctx, sessionId)
	return &MockDriverCloseSessionCall{Call: call}
}

// MockDriverCloseSessionCall wrap *gomock.Call
type MockDriverCloseSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverCloseSessionCall) Return() *MockDriverCloseSessionCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverCloseSessionCall) Do(f func(context.Context, task.SessionId)) *MockDriverCloseSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverCloseSessionCall) DoAndReturn(f func(context.Context, task.SessionId)) *MockDriverCloseSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Execute mocks base method.
func (m *MockDriver) Execute(ctx context.Context, tsk *task.Task, result *task.Result) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, tsk, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockDriverMockRecorder) Execute(ctx, tsk, result any) *MockDriverExecuteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockDriver)(nil).Execute), ctx, tsk, result)
	return &MockDriverExecuteCall{Call: call}
}

// MockDriverExecuteCall wrap *gomock.Call
type MockDriverExecuteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverExecuteCall) Return(arg0 error) *MockDriverExecuteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverExecuteCall) Do(f func(context.Context, *task.Task, *task.Result) error) *MockDriverExecuteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverExecuteCall) DoAndReturn(f func(context.Context, *task.Task, *task.Result) error) *MockDriverExecuteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewLocalSession mocks base method.
func (m *MockDriver) NewLocalSession(ctx context.Context, path string) (task.LocalSession, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewLocalSession", ctx, path)
	ret0, _ := ret[0].(task.LocalSession)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewLocalSession indicates an expected call of NewLocalSession.
func (mr *MockDriverMockRecorder) NewLocalSession(ctx, path any) *MockDriverNewLocalSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewLocalSession", reflect.TypeOf((*MockDriver)(nil).NewLocalSession), ctx, path)
	return &MockDriverNewLocalSessionCall{Call: call}
}

// MockDriverNewLocalSessionCall wrap *gomock.Call
type MockDriverNewLocalSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverNewLocalSessionCall) Return(arg0 task.LocalSession, arg1 error) *MockDriverNewLocalSessionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverNewLocalSessionCall) Do(f func(context.Context, string) (task.LocalSession, error)) *MockDriverNewLocalSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverNewLocalSessionCall) DoAndReturn(f func(context.Context, string) (task.LocalSession, error)) *MockDriverNewLocalSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenSession mocks base method.
func (m *MockDriver) OpenSession(ctx context.Context, session task.Session) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenSession", ctx, session)
	ret0, _ := ret[0].(error)
	return ret0
}

// OpenSession indicates an expected call of OpenSession.
func (mr *MockDriverMockRecorder) OpenSession(ctx, session any) *MockDriverOpenSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenSession", reflect.TypeOf((*MockDriver)(nil).OpenSession), ctx, session)
	return &MockDriverOpenSessionCall{Call: call}
}

// MockDriverOpenSessionCall wrap *gomock.Call
type MockDriverOpenSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverOpenSessionCall) Return(arg0 error) *MockDriverOpenSessionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverOpenSessionCall) Do(f func(context.Context, task.Session) error) *MockDriverOpenSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverOpenSessionCall) DoAndReturn(f func(context.Context, task.Session) error) *MockDriverOpenSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegisterExecutor mocks base method.
func (m *MockDriver) RegisterExecutor(name string, exec task.Executor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterExecutor", name, exec)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterExecutor indicates an expected call of RegisterExecutor.
func (mr *MockDriverMockRecorder) RegisterExecutor(name, exec any) *MockDriverRegisterExecutorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterExecutor", reflect.TypeOf((*MockDriver)(nil).RegisterExecutor), name, exec)
	return &MockDriverRegisterExecutorCall{Call: call}
}

// MockDriverRegisterExecutorCall wrap *gomock.Call
type MockDriverRegisterExecutorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverRegisterExecutorCall) Return(arg0 error) *MockDriverRegisterExecutorCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverRegisterExecutorCall) Do(f func(string, task.Executor) error) *MockDriverRegisterExecutorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverRegisterExecutorCall) DoAndReturn(f func(string, task.Executor) error) *MockDriverRegisterExecutorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Run mocks base method.
func (m *MockDriver) Run() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Run")
}

// Run indicates an expected call of Run.
func (mr *MockDriverMockRecorder) Run() *MockDriverRunCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockDriver)(nil).Run))
	return &MockDriverRunCall{Call: call}
}

// MockDriverRunCall wrap *gomock.Call
type MockDriverRunCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverRunCall) Return() *MockDriverRunCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverRunCall) Do(f func()) *MockDriverRunCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverRunCall) DoAndReturn(f func()) *MockDriverRunCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Shutdown mocks base method.
func (m *MockDriver) Shutdown(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Shutdown", ctx)
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockDriverMockRecorder) Shutdown(ctx any) *MockDriverShutdownCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockDriver)(nil).Shutdown), ctx)
	return &MockDriverShutdownCall{Call: call}
}

// MockDriverShutdownCall wrap *gomock.Call
type MockDriverShutdownCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverShutdownCall) Return() *MockDriverShutdownCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverShutdownCall) Do(f func(context.Context)) *MockDriverShutdownCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverShutdownCall) DoAndReturn(f func(context.Context)) *MockDriverShutdownCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartPlugins mocks base method.
func (m *MockDriver) StartPlugins(ctx context.Context, plugins ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range plugins {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartPlugins", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartPlugins indicates an expected call of StartPlugins.
func (mr *MockDriverMockRecorder) StartPlugins(ctx any, plugins ...any) *MockDriverStartPluginsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, plugins...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartPlugins", reflect.TypeOf((*MockDriver)(nil).StartPlugins), varargs...)
	return &MockDriverStartPluginsCall{Call: call}
}

// MockDriverStartPluginsCall wrap *gomock.Call
type MockDriverStartPluginsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverStartPluginsCall) Return(arg0 error) *MockDriverStartPluginsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverStartPluginsCall) Do(f func(context.Context, ...string) error) *MockDriverStartPluginsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverStartPluginsCall) DoAndReturn(f func(context.Context, ...string) error) *MockDriverStartPluginsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnregisterExecutors mocks base method.
func (m *MockDriver) UnregisterExecutors(names ...string) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range names {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "UnregisterExecutors", varargs...)
}

// UnregisterExecutors indicates an expected call of UnregisterExecutors.
func (mr *MockDriverMockRecorder) UnregisterExecutors(names ...any) *MockDriverUnregisterExecutorsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnregisterExecutors", reflect.TypeOf((*MockDriver)(nil).UnregisterExecutors), names...)
	return &MockDriverUnregisterExecutorsCall{Call: call}
}

// MockDriverUnregisterExecutorsCall wrap *gomock.Call
type MockDriverUnregisterExecutorsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverUnregisterExecutorsCall) Return() *MockDriverUnregisterExecutorsCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverUnregisterExecutorsCall) Do(f func(...string)) *MockDriverUnregisterExecutorsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverUnregisterExecutorsCall) DoAndReturn(f func(...string)) *MockDriverUnregisterExecutorsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
