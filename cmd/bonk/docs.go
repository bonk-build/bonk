// Copyright Â© 2025 Colden Cullen
// SPDX-License-Identifier: MIT

//go:build docs

package main

import (
	"errors"
	"fmt"
	"go/build"
	"io"
	"os"
	"path/filepath"
	"sync"

	"golang.org/x/tools/go/packages"

	"github.com/princjef/gomarkdoc"
	"github.com/princjef/gomarkdoc/format"
	"github.com/princjef/gomarkdoc/lang"
	"github.com/princjef/gomarkdoc/logger"
	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

func prepender(string) string {
	return "<!-- Code generated by cobra. DO NOT EDIT -->\n\n"
}

func identity(str string) string {
	return str
}

func trimFileNewlines(root *os.Root, file string) {
	stat, err := root.Stat(file)
	cobra.CheckErr(err)

	entryFile, err := root.OpenFile(file, os.O_RDWR, stat.Mode().Perm())
	cobra.CheckErr(err)

	size, err := entryFile.Seek(-1, io.SeekEnd)
	cobra.CheckErr(err)

	readBuf := make([]byte, 1)
	foundNewlines := int64(0)

	for {
		read, err := entryFile.Read(readBuf)
		cobra.CheckErr(err)
		if read != 1 {
			cobra.CheckErr(errors.New("failed to read byte in file"))
		}
		char := readBuf[0] //nolint:gosec

		if char == '\n' {
			_, err = entryFile.Seek(-2, io.SeekCurrent)
			cobra.CheckErr(err)
			foundNewlines++
		} else {
			break
		}
	}

	if foundNewlines > 1 {
		err = entryFile.Truncate(size + 1 - (foundNewlines - 1))
		cobra.CheckErr(err)
	}

	err = entryFile.Close()
	cobra.CheckErr(err)
}

type gomarkdocFormatter struct {
	format.GitHubFlavoredMarkdown

	dir string
}

func (f *gomarkdocFormatter) CodeHref(loc lang.Location) (string, error) {
	path, err := filepath.Rel(f.dir, loc.Filepath)
	if err != nil {
		return "", err //nolint:wrapcheck
	}

	var locStr string
	if loc.Start.Line == loc.End.Line {
		locStr = fmt.Sprintf("L%d", loc.Start.Line)
	} else {
		locStr = fmt.Sprintf("L%d-L%d", loc.Start.Line, loc.End.Line)
	}

	return fmt.Sprintf(
		"%s#%s",
		filepath.ToSlash(path),
		locStr,
	), nil
}

func renderMarkdoc() {
	log := logger.New(logger.InfoLevel)

	pkgConfig := packages.Config{
		Mode: packages.NeedName | packages.NeedFiles,
	}
	pkgs, err := packages.Load(&pkgConfig,
		"./pkg/...",
		"./api/...",
	)
	cobra.CheckErr(err)

	for _, pkg := range pkgs {
		dir, err := build.ImportDir(pkg.Dir, 0)
		cobra.CheckErr(err)

		dir.ImportPath = pkg.PkgPath

		docPkg, err := lang.NewPackageFromBuild(log, dir)
		cobra.CheckErr(err)

		file := lang.NewFile("", "", []*lang.Package{docPkg})

		out, err := gomarkdoc.NewRenderer(
			gomarkdoc.WithFormat(&gomarkdocFormatter{
				dir: pkg.Dir,
			}),
		)
		cobra.CheckErr(err)

		result, err := out.File(file)
		cobra.CheckErr(err)

		err = os.WriteFile(filepath.Join(pkg.Dir, "README.md"), []byte(result), 0o600)
		cobra.CheckErr(err)
	}
}

// docsCmd represents the docs command.
var docsCmd = &cobra.Command{
	Use:    "docs",
	Short:  "Generates documentation from the command tree",
	Hidden: true,
	Run: func(_ *cobra.Command, _ []string) {
		// Render package documentation
		renderMarkdoc()

		const docPath = "docs/cmd"
		cobra.CheckErr(os.RemoveAll(docPath))
		cobra.CheckErr(os.MkdirAll(docPath, 0o750))
		cobra.CheckErr(doc.GenMarkdownTreeCustom(rootCmd, docPath, prepender, identity))

		waitGroup := sync.WaitGroup{}

		// Trim extra trailing newlines from each file
		root, err := os.OpenRoot(docPath)
		cobra.CheckErr(err)
		entries, err := os.ReadDir(docPath)
		cobra.CheckErr(err)
		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}

			waitGroup.Go(func() {
				trimFileNewlines(root, entry.Name())
			})
		}

		waitGroup.Wait()
	},
}

func init() {
	rootCmd.AddCommand(docsCmd)
	rootCmd.DisableAutoGenTag = true
	rootCmd.CompletionOptions.DisableDefaultCmd = true
}
